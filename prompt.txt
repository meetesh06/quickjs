Now consider the following- The quickjs bytecode generated contains NOPs which are introduced by the following function pushLabel which introduces NOPs in the first place. This function gets called here in the module body- 
for (int idx = 0; idx < bbList->numArgs; idx++) { IridiumSEXP *bb = bbList->args[idx]; ensureTag(bb, "BB"); pushLabel(ctx, instructions, getFlagNumber(bb, "IDX")); for (int stmtIDX = 0; stmtIDX < bb->numArgs; stmtIDX++) { IridiumSEXP *currStmt = bb->args[stmtIDX]; handleIriStmt(ctx, instructions, currStmt); } } 

Now, I want to remove these NOPs to make the bytecode shorter. 

Suppose, a NOP was located on instruction y. However, due to jump/ goto statements, it is possible that at instruction x, there was a jump to instruction y which would now have to be converted to a jump to the instruction which followed the NOP. These would have to be repatched. 

Moreover, suppose an instruction p has a jump to a general instruction q(not an NOP). Deletion of the NOP may cause this jump location to change as well, and would thus have to be corrected.
How do I implement this without running into the problem of stack underflow?

Would it be better to solve this problem by not generating the NOPs in the first place and using a different mechanism than introducing NOPs via pushLabel?

function shortJump() { if (false) return; }

The initial bytecode is as follows-
╰─$ qjs -K /home/maverick/js_project/Iridium/test.json/test.json
peekaboo
kenechi
ADDR: 0x6259340accb0
function: <null>
  mode: strict
  locals:
    0: const this
  closure vars:
    0: shortJump local:loc0 var
  stack_size: 1
  byte_code_len: 24
  opcodes: 12
;; <TestFunc>
        nop            
        push_this      
        if_false8       5
        return_undef   
    5:  push_this      
        put_loc         0    ; this
        push_const      0    ; uninitialized
        put_var_ref     0    ; shortJump
        fclosure8       1    ; undefined
        put_var_ref     0    ; shortJump
        undefined      
        return_async   
peekaboo
kenechi
ADDR: 0x6259340ace30
function: <null>
  mode: strict
  locals:
    0: const this [level:1 next:0]
    1: var ifTest$1 [level:1 next:0]
  stack_size: 1
  byte_code_len: 39
  opcodes: 15
;; <TestFunc>
        nop            
        push_this      
        put_loc         0    ; this
        push_const      0    ; uninitialized
        put_loc         1    ; ifTest$1
        push_false     
        put_loc         1    ; ifTest$1
        get_loc_check   1    ; ifTest$1
        if_true         32
        goto            31
        nop            
   31:  nop            
   32:  undefined      
        return         
        goto            31

First find the correct bytecode after removing NOPs for this example and use that knowledge to properly implement the changes required for doing this generally. Make sure that you do not run into stack underflow error. For your reference, the below method which I tried leads to a stack underflow problem-

