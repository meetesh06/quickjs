diff --git a/iridium.c b/iridium.c
index b865262..60bccc8 100644
--- a/iridium.c
+++ b/iridium.c
@@ -8,13 +8,6 @@
 #include <assert.h>
 #include <ctype.h>

-#define check_dump_flag(ctx, flag) ((JS_GetDumpFlags(ctx->rt) & (flag + 0)) == (flag + 0))
-
-#define OP_DEFINE_METHOD_METHOD 0
-#define OP_DEFINE_METHOD_GETTER 1
-#define OP_DEFINE_METHOD_SETTER 2
-#define OP_DEFINE_METHOD_ENUMERABLE 4
-
 #define JS_STACK_SIZE_MAX 65534
 
 typedef enum OPCodeFormat
@@ -319,8 +312,6 @@ typedef struct BCLList
     uint32_t four;
   } data;
   uint8_t valueSize;
-  bool hasFlags;
-  uint8_t flags;
   // Extend the data structure to accomodate arguments dynamically
 } BCLList;
 
@@ -338,28 +329,10 @@ BCLList *pushLabel(JSContext *ctx, BCLList *currTarget, int label)
   currTarget->label = label;
   currTarget->valueSize = 0;
   currTarget->data.four = 0;
-  currTarget->hasFlags = false;
-  currTarget->flags = 0;
   return currTarget;
 }
 
-// BCLList *push8(JSContext *ctx, BCLList *currTarget, uint8_t opcode)
-// {
-//   currTarget->next = malloc(sizeof(BCLList));
-//   currTarget = currTarget->next;
-//   currTarget->next = NULL;
-//   currTarget->bc = opcode;
-//   currTarget->lambdaPoolReference = false;
-//   currTarget->hasPoolData = false;
-//   currTarget->poolData = JS_UNINITIALIZED;
-//   currTarget->isLabel = false;
-//   currTarget->label = 0;
-//   currTarget->valueSize = 0;
-//   currTarget->data.four = 0;
-//   return currTarget;
-// }
-
-BCLList *pushOP(JSContext *ctx, BCLList *currTarget, OPCodeEnum opcode)
+BCLList *push8(JSContext *ctx, BCLList *currTarget, uint8_t opcode)
 {
   currTarget->next = malloc(sizeof(BCLList));
   currTarget = currTarget->next;
@@ -372,12 +345,10 @@ BCLList *pushOP(JSContext *ctx, BCLList *currTarget, OPCodeEnum opcode)
   currTarget->label = 0;
   currTarget->valueSize = 0;
   currTarget->data.four = 0;
-  currTarget->hasFlags = false;
-  currTarget->flags = 0;
   return currTarget;
 }
 
-BCLList *pushOPFlags(JSContext *ctx, BCLList *currTarget, OPCodeEnum opcode, uint8_t flags)
+BCLList *pushOP(JSContext *ctx, BCLList *currTarget, OPCodeEnum opcode)
 {
   currTarget->next = malloc(sizeof(BCLList));
   currTarget = currTarget->next;
@@ -390,8 +361,6 @@ BCLList *pushOPFlags(JSContext *ctx, BCLList *currTarget, OPCodeEnum opcode, uin
   currTarget->label = 0;
   currTarget->valueSize = 0;
   currTarget->data.four = 0;
-  currTarget->hasFlags = true;
-  currTarget->flags = flags;
   return currTarget;
 }
 
@@ -408,8 +377,6 @@ BCLList *pushOP8(JSContext *ctx, BCLList *currTarget, OPCodeEnum opcode, uint8_t
   currTarget->label = 0;
   currTarget->valueSize = 1;
   currTarget->data.one = data;
-  currTarget->hasFlags = false;
-  currTarget->flags = 0;
   return currTarget;
 }
 
@@ -426,8 +393,6 @@ BCLList *pushOP16(JSContext *ctx, BCLList *currTarget, OPCodeEnum opcode, uint16
   currTarget->label = 0;
   currTarget->valueSize = 2;
   currTarget->data.two = data;
-  currTarget->hasFlags = false;
-  currTarget->flags = 0;
   return currTarget;
 }
 
@@ -444,26 +409,6 @@ BCLList *pushOP32(JSContext *ctx, BCLList *currTarget, OPCodeEnum opcode, uint32
   currTarget->label = 0;
   currTarget->valueSize = 4;
   currTarget->data.four = data;
-  currTarget->hasFlags = false;
-  currTarget->flags = 0;
-  return currTarget;
-}
-
-BCLList *pushOP32Flags(JSContext *ctx, BCLList *currTarget, OPCodeEnum opcode, uint32_t data, uint8_t flags)
-{
-  currTarget->next = malloc(sizeof(BCLList));
-  currTarget = currTarget->next;
-  currTarget->next = NULL;
-  currTarget->bc = opcode;
-  currTarget->lambdaPoolReference = false;
-  currTarget->hasPoolData = false;
-  currTarget->poolData = JS_UNINITIALIZED;
-  currTarget->isLabel = false;
-  currTarget->label = 0;
-  currTarget->valueSize = 4;
-  currTarget->data.four = data;
-  currTarget->hasFlags = true;
-  currTarget->flags = flags;
   return currTarget;
 }
 
@@ -480,8 +425,6 @@ BCLList *pushOPConst(JSContext *ctx, BCLList *currTarget, OPCodeEnum opcode, JSV
   currTarget->label = 0;
   currTarget->valueSize = 4;
   currTarget->data.four = 0;
-  currTarget->hasFlags = false;
-  currTarget->flags = 0;
   return currTarget;
 }
 
@@ -546,17 +489,6 @@ int getFlagNumber(IridiumSEXP *binding, char *flagName)
   exit(1);
 }
 
-double getFlagDouble(IridiumSEXP *binding, char *flagName)
-{
-  IridiumFlag *flag = getFlag(binding, flagName);
-  if (flag->datatype == NUMBER)
-  {
-    return flag->value.number;
-  }
-  fprintf(stderr, "TODO: failed to get NUMBER(double)\n");
-  exit(1);
-}
-
 char *getFlagString(IridiumSEXP *binding, char *flagName)
 {
   IridiumFlag *flag = getFlag(binding, flagName);
@@ -593,7 +525,7 @@ int getFlagNull(IridiumSEXP *binding, char *flagName)
 
 // ============== Code Generation ============== //
 
-BCLList *handleEnvWrite(JSContext *ctx, BCLList *currTarget, IridiumSEXP *currStmt, bool saveResToStack);
+BCLList *handleEnvWrite(JSContext *ctx, BCLList *currTarget, IridiumSEXP *currStmt);
 
 int parse_arg_index(const char *str)
 {
@@ -614,155 +546,9 @@ int parse_arg_index(const char *str)
   return atoi(number_part);
 }
 
-// ============== Misc ============== //
-
-BCLList *storeWhatevesOnTheStack(JSContext *ctx, IridiumSEXP *loc, BCLList *currTarget, bool safe, bool thisInit, bool isStrict, bool saveResToStack)
-{
-  if (saveResToStack)
-    currTarget = pushOP(ctx, currTarget, OP_dup);
-
-  // is lval global?
-  if (isTag(loc, "GlobalBinding"))
-  {
-    char *name = getFlagString(loc, "NAME");
-
-    if (safe)
-    {
-      currTarget = pushOP32(ctx, currTarget, OP_put_var_init, JS_NewAtom(ctx, name));
-    }
-    else if (isStrict)
-    {
-      currTarget = pushOP32(ctx, currTarget, OP_check_var, JS_NewAtom(ctx, name));
-      currTarget = pushOP(ctx, currTarget, OP_swap);
-      currTarget = pushOP32(ctx, currTarget, OP_put_var_strict, JS_NewAtom(ctx, name));
-    }
-    else
-    {
-      currTarget = pushOP32(ctx, currTarget, OP_put_var, JS_NewAtom(ctx, name));
-    }
-  }
-  else
-  {
-    if (isTag(loc, "RemoteEnvBinding"))
-    {
-      int refIdx = getFlagNumber(loc, "REFIDX");
-      currTarget = pushOP16(ctx, currTarget, thisInit ? OP_put_var_ref_check_init : safe ? OP_put_var_ref
-                                                                                         : OP_put_var_ref_check,
-                            refIdx);
-    }
-    else if (isTag(loc, "EnvBinding"))
-    {
-      int refIdx = getFlagNumber(loc, "REFIDX");
-      currTarget = pushOP16(ctx, currTarget, thisInit ? OP_put_loc_check_init : safe ? OP_put_loc
-                                                                                     : OP_put_loc_check,
-                            refIdx);
-    }
-    else
-    {
-      fprintf(stderr, "TODO: store on stack, unhandled loc kind!!");
-      exit(1);
-    }
-  }
-
-  return currTarget;
-}
-
-// Gemini 2.5 pro, got it right, maybe...
-BCLList *keepNDropM(JSContext *ctx, BCLList *currTarget, int N, int M)
-{
-  // If M is zero or negative, no elements need to be dropped.
-  if (M <= 0)
-  {
-    return currTarget;
-  }
-
-  // If N is negative, it's an invalid input. Do nothing.
-  if (N < 0)
-  {
-    fprintf(stderr, "TODO: keepMDropN, invalid input !!");
-    exit(1);
-  }
-
-  if (N == 2 && M == 1)
-  {
-    currTarget = pushOP(ctx, currTarget, OP_nip1);
-    return currTarget;
-  }
-  fprintf(stderr, "TODO: keepMDropN, handle general case, validate code!!");
-  exit(1);
-
-  // Validate the logic for correctness first...
-  // printf("Executing general path for N=%d, M=%d:\n", N, M);
-  // // General case: Loop M times, each time dropping the element at depth N+1.
-  // for (int i = 0; i < M; ++i)
-  // {
-  //   // The depth of the element to drop is always N+1 relative to the
-  //   // block of N elements we are preserving.
-  //   const int depth_to_drop = N + 1;
-
-  //   switch (depth_to_drop)
-  //   {
-  //   case 1:
-  //     // Keep 0, drop 1. This is a simple drop.
-  //     currTarget = pushOP(ctx, currTarget, OP_drop);
-  //     break;
-  //   case 2:
-  //     // Keep 1, drop 1. The element to drop is at depth 2.
-  //     // This is what `nip` does.
-  //     currTarget = pushOP(ctx, currTarget, OP_nip);
-  //     break;
-  //   case 3:
-  //     // Keep 2, drop 1. The element to drop is at depth 3.
-  //     // This is what `nip1` does.
-  //     currTarget = pushOP(ctx, currTarget, OP_nip1);
-  //     break;
-  //   case 4:
-  //     // Keep 3, drop 1. The element to drop is at depth 4.
-  //     // We achieve this by moving the 4th element to the top (`rot4l`)
-  //     // and then dropping it (`drop`).
-  //     currTarget = pushOP(ctx, currTarget, OP_rot4l);
-  //     currTarget = pushOP(ctx, currTarget, OP_drop);
-  //     break;
-  //   case 5:
-  //     // Keep 4, drop 1. The element to drop is at depth 5.
-  //     // We achieve this by moving the 5th element to the top (`rot5l`)
-  //     // and then dropping it (`drop`).
-  //     currTarget = pushOP(ctx, currTarget, OP_rot5l);
-  //     currTarget = pushOP(ctx, currTarget, OP_drop);
-  //     break;
-  //   default:
-  //     // The provided primitives do not support direct manipulation
-  //     // of elements at depths greater than 5. Therefore, a general
-  //     // solution for N > 4 is not possible with this instruction set.
-  //     // In a real compiler, you might emit a call to a runtime
-  //     // helper function or raise a compile-time error.
-  //     fprintf(stderr, "Error: Cannot keepNDropM for N=%d. Operation not supported for depths > 5.\n", N);
-  //     // Returning without emitting any more opcodes for this drop operation.
-  //     break;
-  //   }
-  // }
-
-  return currTarget;
-}
-
-// ============== Misc ============== //
-
 BCLList *lowerToStack(JSContext *ctx, BCLList *currTarget, IridiumSEXP *rval)
 {
-  if (isTag(rval, "JSForInStart"))
-  {
-    // Push obj onto the stack
-    currTarget = lowerToStack(ctx, currTarget, rval->args[0]);
-
-    // obj -> enum_obj
-    return pushOP(ctx, currTarget, OP_for_in_start);
-  }
-  else if (isTag(rval, "JSToObject"))
-  {
-    currTarget = lowerToStack(ctx, currTarget, rval->args[0]);
-    return pushOP(ctx, currTarget, OP_to_object);
-  }
-  else if (isTag(rval, "String"))
+  if (isTag(rval, "String"))
   {
     char *data = getFlagString(rval, "IridiumPrimitive");
     JSAtom strAtom = JS_NewAtom(ctx, data);
@@ -803,7 +589,7 @@ BCLList *lowerToStack(JSContext *ctx, BCLList *currTarget, IridiumSEXP *rval)
   }
   else if (isTag(rval, "Number"))
   {
-    double data = getFlagDouble(rval, "IridiumPrimitive");
+    int data = getFlagNumber(rval, "IridiumPrimitive");
     JSValue jsvalue = JS_NewNumber(ctx, data);
     return pushOPConst(ctx, currTarget, OP_push_const, jsvalue);
   }
@@ -821,18 +607,10 @@ BCLList *lowerToStack(JSContext *ctx, BCLList *currTarget, IridiumSEXP *rval)
     // If this is an arg, get the arg idx
     if (hasFlag(rval, "JSARG"))
     {
-      int argIdx = getFlagNumber(rval, "REFIDX");
-      // int argIdx = parse_arg_index(getFlagString(rval->args[0], "IridiumPrimitive"));
+      int argIdx = parse_arg_index(getFlagString(rval->args[0], "IridiumPrimitive"));
       assert(argIdx > -1);
       return pushOP16(ctx, currTarget, OP_get_arg, argIdx);
     }
-    else if (hasFlag(rval, "JSRESTARG"))
-    {
-      int argIdx = getFlagNumber(rval, "REFIDX");
-      // int argIdx = parse_arg_index(getFlagString(rval->args[0], "IridiumPrimitive"));
-      assert(argIdx > -1);
-      return pushOP16(ctx, currTarget, OP_rest, argIdx);
-    }
     else
     {
       int refIDX = getFlagNumber(rval, "REFIDX");
@@ -841,11 +619,11 @@ BCLList *lowerToStack(JSContext *ctx, BCLList *currTarget, IridiumSEXP *rval)
   }
   else if (isTag(rval, "GlobalBinding"))
   {
-    char *lookupVal = getFlagString(rval, "NAME");
+    char *lookupVal = getFlagString(rval->args[0], "IridiumPrimitive");
     if (strcmp(lookupVal, "undefined") == 0)
       return pushOP(ctx, currTarget, OP_undefined);
     else
-      return pushOP32(ctx, currTarget, OP_get_var, JS_NewAtom(ctx, lookupVal));
+      return pushOP32(ctx, currTarget, OP_get_var, JS_NewAtom(ctx, getFlagString(rval->args[0], "IridiumPrimitive")));
   }
   else if (isTag(rval, "CallSite"))
   {
@@ -866,7 +644,7 @@ BCLList *lowerToStack(JSContext *ctx, BCLList *currTarget, IridiumSEXP *rval)
       assert(rval->numArgs >= 2);
       currTarget = lowerToStack(ctx, currTarget, rval->args[0]);
       currTarget = lowerToStack(ctx, currTarget, rval->args[1]);
-      currTarget = pushOP(ctx, currTarget, OP_check_brand); // Ensure the function's home object's brand matches the brand of the current instance.
+      currTarget = pushOP(ctx, currTarget, OP_check_brand); // Ensure the function's home object's brand matches the brand of the current instance current instance.
       i = 2;
     }
 
@@ -904,7 +682,7 @@ BCLList *lowerToStack(JSContext *ctx, BCLList *currTarget, IridiumSEXP *rval)
   }
   else if (isTag(rval, "EnvWrite"))
   {
-    return handleEnvWrite(ctx, currTarget, rval, true);
+    return handleEnvWrite(ctx, currTarget, rval);
   }
   else if (isTag(rval, "Boolean"))
   {
@@ -946,31 +724,6 @@ BCLList *lowerToStack(JSContext *ctx, BCLList *currTarget, IridiumSEXP *rval)
       currTarget = lowerToStack(ctx, currTarget, rval->args[1]);
       return pushOP(ctx, currTarget, OP_typeof);
     }
-    else if (strcmp(op, "delete") == 0)
-    {
-      IridiumSEXP *valToDelete = rval->args[1];
-      assert(isTag(valToDelete, "List"));
-      if (hasFlag(valToDelete, "UNOP_DEL_MEMBEREXPR"))
-      {
-        IridiumSEXP *receiver = valToDelete->args[0];
-        IridiumSEXP *field = valToDelete->args[1];
-        currTarget = lowerToStack(ctx, currTarget, receiver);
-        currTarget = lowerToStack(ctx, currTarget, field);
-        return pushOP(ctx, currTarget, OP_delete);
-      }
-      else if (hasFlag(valToDelete, "UNOP_DEL_VAR"))
-      {
-        IridiumSEXP *var = valToDelete->args[0];
-        assert(isTag(var, "String"));
-        JSAtom varAtom = JS_NewAtom(ctx, getFlagString(var, "IridiumPrimitive"));
-        return pushOP32(ctx, currTarget, OP_delete_var, varAtom);
-      }
-      else
-      {
-        fprintf(stderr, "TODO: Unhandled : %s\n", op);
-        exit(1);
-      }
-    }
     else
     {
       fprintf(stderr, "TODO: unhandled Unop: %s\n", op);
@@ -1163,22 +916,57 @@ BCLList *lowerToStack(JSContext *ctx, BCLList *currTarget, IridiumSEXP *rval)
     return pushOP(ctx, currTarget, OP_drop);
   }
 
+#define OP_DEFINE_METHOD_METHOD 0
+#define OP_DEFINE_METHOD_GETTER 1
+#define OP_DEFINE_METHOD_SETTER 2
+#define OP_DEFINE_METHOD_ENUMERABLE 4
+
+  else if (isTag(rval, "JSObjectMethod"))
+  {
+    IridiumSEXP *val = rval->args[1];
+    currTarget = lowerToStack(ctx, currTarget, val);
+
+    IridiumSEXP *field = rval->args[0];
+    ensureTag(field, "String");
+    JSAtom fieldAtom = JS_NewAtom(ctx, getFlagString(field, "IridiumPrimitive"));
+    currTarget = pushOP32(ctx, currTarget, OP_define_method, fieldAtom);
+    uint8_t op_flag;
+    if (hasFlag(rval, "METHOD"))
+    {
+      op_flag = OP_DEFINE_METHOD_METHOD | OP_DEFINE_METHOD_ENUMERABLE;
+    }
+    else if (hasFlag(rval, "GET"))
+    {
+      op_flag = OP_DEFINE_METHOD_GETTER | OP_DEFINE_METHOD_ENUMERABLE;
+    }
+    else if (hasFlag(rval, "SET"))
+    {
+      op_flag = OP_DEFINE_METHOD_SETTER | OP_DEFINE_METHOD_ENUMERABLE;
+    }
+    else
+    {
+      fprintf(stderr, "TODO: JSObjectMethod invalid flag\n");
+      exit(1);
+    }
+    return push8(ctx, currTarget, op_flag);
+  }
+
   else if (isTag(rval, "JSObject"))
   {
-    return pushOP(ctx, currTarget, OP_object);
-    // for (int i = 0; i < rval->numArgs; i++)
-    // {
-    //   IridiumSEXP *ele = rval->args[i];
-    //   if (isTag(ele, "JSObjectProp") || isTag(ele, "JSComputedObjectProp") || isTag(ele, "JSObjectMethod"))
-    //   {
-    //     currTarget = lowerToStack(ctx, currTarget, ele);
-    //   }
-    //   else
-    //   {
-    //     fprintf(stderr, "TODO: unhandled Object Init Element: %s\n", ele->tag);
-    //     exit(1);
-    //   }
-    // }
+    currTarget = pushOP(ctx, currTarget, OP_object);
+    for (int i = 0; i < rval->numArgs; i++)
+    {
+      IridiumSEXP *ele = rval->args[i];
+      if (isTag(ele, "JSObjectProp") || isTag(ele, "JSComputedObjectProp") || isTag(ele, "JSObjectMethod"))
+      {
+        currTarget = lowerToStack(ctx, currTarget, ele);
+      }
+      else
+      {
+        fprintf(stderr, "TODO: unhandled Object Init Element: %s\n", ele->tag);
+        exit(1);
+      }
+    }
   }
   else if (isTag(rval, "PoolBinding"))
   {
@@ -1203,9 +991,16 @@ BCLList *lowerToStack(JSContext *ctx, BCLList *currTarget, IridiumSEXP *rval)
       currTarget->lambdaPoolReference = true;
     }
 
-    uint8_t flags = hasFlag(rval, "Derived") ? 1 : 0;
-    currTarget = pushOP32Flags(ctx, currTarget, OP_define_class, classNameAtom, flags);
+    currTarget = pushOP32(ctx, currTarget, OP_define_class, classNameAtom);
     // Class Flags, the bytecode itself is 5 + 1 bytes (1 byte OPcode + 4 byte name + 1 byte flags)
+    if (hasFlag(rval, "Derived"))
+    {
+      currTarget = push8(ctx, currTarget, 1);
+    }
+    else
+    {
+      currTarget = push8(ctx, currTarget, 0);
+    }
 
     // Set home object for classPropInitClosure
     IridiumSEXP *classPropInitClos = rval->args[3];
@@ -1219,28 +1014,6 @@ BCLList *lowerToStack(JSContext *ctx, BCLList *currTarget, IridiumSEXP *rval)
     {
       IridiumSEXP *methodName = methodList->args[i]->args[0];
       IridiumSEXP *methodLambda = methodList->args[i]->args[1];
-      IridiumSEXP *methodKind = methodList->args[i]->args[2];
-      assert(isTag(methodKind, "String"));
-      char *kindStr = getFlagString(methodKind, "IridiumPrimitive");
-      uint8_t op_flag;
-
-      if (strcmp(kindStr, "METHOD") == 0)
-      {
-        op_flag = OP_DEFINE_METHOD_METHOD;
-      }
-      else if (strcmp(kindStr, "GET") == 0)
-      {
-        op_flag = OP_DEFINE_METHOD_GETTER;
-      }
-      else if (strcmp(kindStr, "SET") == 0)
-      {
-        op_flag = OP_DEFINE_METHOD_SETTER;
-      }
-      else
-      {
-        fprintf(stderr, "TODO: Classmethod flag is invalid\n");
-        exit(1);
-      }
 
       if (isTag(methodName, "String"))
       {
@@ -1252,7 +1025,8 @@ BCLList *lowerToStack(JSContext *ctx, BCLList *currTarget, IridiumSEXP *rval)
         JSAtom fieldAtom = JS_NewAtom(ctx, getFlagString(methodName, "IridiumPrimitive"));
 
         // Define method on the prototype
-        currTarget = pushOP32Flags(ctx, currTarget, OP_define_method, fieldAtom, op_flag);
+        currTarget = pushOP32(ctx, currTarget, OP_define_method, fieldAtom);
+        currTarget = push8(ctx, currTarget, OP_DEFINE_METHOD_METHOD);
       }
       else if (isTag(methodName, "EnvRead"))
       {
@@ -1263,7 +1037,8 @@ BCLList *lowerToStack(JSContext *ctx, BCLList *currTarget, IridiumSEXP *rval)
         currTarget = lowerToStack(ctx, currTarget, methodLambda);
 
         // Define method on the prototype
-        currTarget = pushOPFlags(ctx, currTarget, OP_define_method_computed, op_flag);
+        currTarget = pushOP(ctx, currTarget, OP_define_method_computed);
+        currTarget = push8(ctx, currTarget, OP_DEFINE_METHOD_METHOD);
       }
       else if (isTag(methodName, "Private"))
       {
@@ -1288,28 +1063,6 @@ BCLList *lowerToStack(JSContext *ctx, BCLList *currTarget, IridiumSEXP *rval)
     {
       IridiumSEXP *methodName = staticMethodList->args[i]->args[0];
       IridiumSEXP *methodLambda = staticMethodList->args[i]->args[1];
-      IridiumSEXP *methodKind = staticMethodList->args[i]->args[2];
-      assert(isTag(methodKind, "String"));
-      char *kindStr = getFlagString(methodKind, "IridiumPrimitive");
-      uint8_t op_flag;
-
-      if (strcmp(kindStr, "METHOD") == 0)
-      {
-        op_flag = OP_DEFINE_METHOD_METHOD;
-      }
-      else if (strcmp(kindStr, "GET") == 0)
-      {
-        op_flag = OP_DEFINE_METHOD_GETTER;
-      }
-      else if (strcmp(kindStr, "SET") == 0)
-      {
-        op_flag = OP_DEFINE_METHOD_SETTER;
-      }
-      else
-      {
-        fprintf(stderr, "TODO: Classmethod flag is invalid\n");
-        exit(1);
-      }
 
       if (isTag(methodName, "String"))
       {
@@ -1321,7 +1074,8 @@ BCLList *lowerToStack(JSContext *ctx, BCLList *currTarget, IridiumSEXP *rval)
         JSAtom fieldAtom = JS_NewAtom(ctx, getFlagString(methodName, "IridiumPrimitive"));
 
         // Define method on the prototype
-        currTarget = pushOP32Flags(ctx, currTarget, OP_define_method, fieldAtom, op_flag);
+        currTarget = pushOP32(ctx, currTarget, OP_define_method, fieldAtom);
+        currTarget = push8(ctx, currTarget, OP_DEFINE_METHOD_METHOD);
       }
       else if (isTag(methodName, "EnvRead"))
       {
@@ -1332,7 +1086,8 @@ BCLList *lowerToStack(JSContext *ctx, BCLList *currTarget, IridiumSEXP *rval)
         currTarget = lowerToStack(ctx, currTarget, methodLambda);
 
         // Define method on the prototype
-        currTarget = pushOPFlags(ctx, currTarget, OP_define_method_computed, op_flag);
+        currTarget = pushOP(ctx, currTarget, OP_define_method_computed);
+        currTarget = push8(ctx, currTarget, OP_DEFINE_METHOD_METHOD);
       }
       else if (isTag(methodName, "Private"))
       {
@@ -1419,197 +1174,300 @@ BCLList *lowerToStack(JSContext *ctx, BCLList *currTarget, IridiumSEXP *rval)
   {
     return pushOP(ctx, currTarget, OP_null);
   }
-  else if (isTag(rval, "BitInt"))
+  else if (isTag(rval, "Yield"))
+  {
+    currTarget = lowerToStack(ctx, currTarget, rval->args[0]);
+    return pushOP(ctx, currTarget, OP_yield);
+  }
+  else if (isTag(rval, "Await"))
+  {
+    currTarget = lowerToStack(ctx, currTarget, rval->args[0]);
+    return pushOP(ctx, currTarget, OP_await);
+  }
+  else
   {
-    char *str = getFlagString(rval, "IridiumPrimitive");
+    fprintf(stderr, "TODO: unhandled RVal: %s\n", rval->tag);
+    exit(1);
+  }
+  return currTarget;
+}
 
-    // char *endptr;
+bool isSimpleAssignment(IridiumSEXP *currStmt)
+{
+  return currStmt->numArgs == 2 && (isTag(currStmt->args[0], "EnvBinding") || isTag(currStmt->args[0], "RemoteEnvBinding"));
+}
 
-    // errno = 0; // Reset errno before call
-    // int64_t value = strtoll(str, &endptr, 10);
+BCLList *handleEnvWrite(JSContext *ctx, BCLList *currTarget, IridiumSEXP *currStmt)
+{
+  bool safe = getFlagBoolean(currStmt, "SAFE");
+  bool thisInit = getFlagBoolean(currStmt, "THISINIT");
+  // BINDING = VAL
+  if (isSimpleAssignment(currStmt))
+  {
+    IridiumSEXP *lval = currStmt->args[0];
+    IridiumSEXP *rval = currStmt->args[1];
 
-    // if (errno == ERANGE)
-    // {
-    //   fprintf(stderr, "BIGINT: BitInt: Overflow/Underflow occurred\n");
-    //   exit(1);
-    // }
-    // else if (endptr == str)
-    // {
-    //   fprintf(stderr, "BIGINT: BitInt: No digits were found\n");
-    //   exit(1);
-    // }
+    // Lower RVal
+    if (isTag(rval, "EnvWrite"))
+    {
+      bool safe = getFlagBoolean(rval, "SAFE");
+      bool thisInit = getFlagBoolean(rval, "THISINIT");
 
-    // JSValue val = JS_NewBigInt64(ctx, value);
-    // return pushOPConst(ctx, currTarget, OP_push_const, val);
+      IridiumSEXP *innerLVal = rval->args[0];
+      IridiumSEXP *innerRval = rval->args[1];
+      assert(!isTag(innerRval, "EnvWrite"));
+
+      // Lower and dup RVal
+      currTarget = lowerToStack(ctx, currTarget, innerRval);
+      currTarget = pushOP(ctx, currTarget, OP_dup);
 
-    JSBigInt *r;
-    JSValue val;
-    r = js_bigint_from_string(ctx, str, 10);
-    if (!r)
+      // Inner LVal
+      if (thisInit)
+      {
+        // This init only happens for locals...
+        assert(isTag(innerLVal, "EnvBinding"));
+        int refIdx = getFlagNumber(innerLVal, "REFIDX");
+        currTarget = pushOP16(ctx, currTarget, OP_put_loc_check_init, refIdx);
+      }
+      else if (isTag(innerLVal, "RemoteEnvBinding"))
+      {
+        int refIdx = getFlagNumber(innerLVal, "REFIDX");
+        currTarget = pushOP16(ctx, currTarget, safe ? OP_put_var_ref : OP_put_var_ref_check, refIdx);
+      }
+      else if (isTag(innerLVal, "EnvBinding"))
+      {
+        int refIdx = getFlagNumber(innerLVal, "REFIDX");
+        currTarget = pushOP16(ctx, currTarget, safe ? OP_put_loc : OP_put_loc_check, refIdx);
+      }
+      else
+      {
+        fprintf(stderr, "TODO: Unhandled LVal kind!!");
+        exit(1);
+      }
+    }
+    else if (isTag(rval, "FieldWrite"))
     {
-      val = JS_ThrowOutOfMemory(ctx);
+      // Receiver
+      IridiumSEXP *receiver = rval->args[0];
+      currTarget = lowerToStack(ctx, currTarget, receiver);
+
+      // Rval
+      IridiumSEXP *valToPush = rval->args[2];
+      currTarget = lowerToStack(ctx, currTarget, valToPush);
+      currTarget = pushOP(ctx, currTarget, OP_dup);
+      currTarget = pushOP(ctx, currTarget, OP_rot3r);
+
+      // Field
+      IridiumSEXP *field = rval->args[1];
+      ensureTag(field, "String");
+      JSAtom fieldAtom = JS_NewAtom(ctx, getFlagString(field, "IridiumPrimitive"));
+      currTarget = pushOP32(ctx, currTarget, OP_put_field, fieldAtom);
+    }
+
+    else if (isTag(rval, "JSComputedFieldWrite"))
+    {
+
+      IridiumSEXP *assnVal = rval->args[2];
+      currTarget = lowerToStack(ctx, currTarget, assnVal);
+
+      IridiumSEXP *receiver = rval->args[0];
+      currTarget = lowerToStack(ctx, currTarget, receiver);
+
+      IridiumSEXP *field = rval->args[1];
+      currTarget = lowerToStack(ctx, currTarget, field);
+      currTarget = pushOP(ctx, currTarget, OP_to_propkey);
+
+      currTarget = lowerToStack(ctx, currTarget, assnVal);
+
+      currTarget = pushOP(ctx, currTarget, OP_put_array_el); // obj prop val
+    }
+    else
+    {
+      // Lower RVal
+      currTarget = lowerToStack(ctx, currTarget, rval);
+    }
+
+    // Lower LVal
+    if (thisInit)
+    {
+      // This init only happens for locals...
+      assert(isTag(lval, "EnvBinding"));
+      int refIdx = getFlagNumber(lval, "REFIDX");
+      currTarget = pushOP16(ctx, currTarget, OP_put_loc_check_init, refIdx);
+    }
+    else if (isTag(lval, "RemoteEnvBinding"))
+    {
+      int refIdx = getFlagNumber(lval, "REFIDX");
+      currTarget = pushOP16(ctx, currTarget, safe ? OP_put_var_ref : OP_put_var_ref_check, refIdx);
+    }
+    else if (isTag(lval, "EnvBinding"))
+    {
+      int refIdx = getFlagNumber(lval, "REFIDX");
+      currTarget = pushOP16(ctx, currTarget, safe ? OP_put_loc : OP_put_loc_check, refIdx);
+    }
+    else
+    {
+      fprintf(stderr, "TODO: Unhandled LVal kind!!");
+      exit(1);
     }
-    val = JS_CompactBigInt(ctx, r);
-    return pushOPConst(ctx, currTarget, OP_push_const, val);
-  }
-  else if (isTag(rval, "Await"))
-  {
-    currTarget = lowerToStack(ctx, currTarget, rval->args[0]);
-    return pushOP(ctx, currTarget, OP_await);
   }
-  else if (isTag(rval, "Nope"))
+  else
   {
-    return currTarget;
+    fprintf(stderr, "TODO: unhandled env write: %s\n", currStmt->tag);
+    exit(1);
   }
-  else if (isTag(rval, "FieldWrite"))
+
+  return currTarget;
+}
+
+BCLList *handleIriStmt(JSContext *ctx, BCLList *currTarget, IridiumSEXP *currStmt)
+{
+  if (isTag(currStmt, "FieldWrite"))
   {
     // Receiver
-    IridiumSEXP *receiver = rval->args[0];
+    IridiumSEXP *receiver = currStmt->args[0];
     currTarget = lowerToStack(ctx, currTarget, receiver);
 
     // Rval
-    IridiumSEXP *valToPush = rval->args[2];
+    IridiumSEXP *valToPush = currStmt->args[2];
     currTarget = lowerToStack(ctx, currTarget, valToPush);
-    currTarget = pushOP(ctx, currTarget, OP_dup);
-    currTarget = pushOP(ctx, currTarget, OP_rot3r);
 
     // Field
-    IridiumSEXP *field = rval->args[1];
+    IridiumSEXP *field = currStmt->args[1];
     ensureTag(field, "String");
     JSAtom fieldAtom = JS_NewAtom(ctx, getFlagString(field, "IridiumPrimitive"));
     currTarget = pushOP32(ctx, currTarget, OP_put_field, fieldAtom);
-
-    return currTarget;
   }
-  else if (isTag(rval, "JSComputedFieldWrite"))
+  else if (isTag(currStmt, "JSForInNext"))
   {
-    // Receiver
-    IridiumSEXP *receiver = rval->args[0];
-    currTarget = lowerToStack(ctx, currTarget, receiver);
-
-    // Field
-    IridiumSEXP *field = rval->args[1];
-    currTarget = lowerToStack(ctx, currTarget, field);
-    currTarget = pushOP(ctx, currTarget, OP_to_propkey);
-
-    // Rval
-    IridiumSEXP *assnVal = rval->args[2];
-    currTarget = lowerToStack(ctx, currTarget, assnVal);
-
-    // Receiver Field Rval -> Rval Receiver Field Rval
-    currTarget = pushOP(ctx, currTarget, OP_insert3);
-
-    currTarget = pushOP(ctx, currTarget, OP_put_array_el); // Receiver Field Rval
-  }
-  else if (isTag(rval, "JSADDBRAND"))
-  {
-    currTarget = lowerToStack(ctx, currTarget, rval->args[0]);
-    currTarget = lowerToStack(ctx, currTarget, rval->args[1]);
-    return pushOP(ctx, currTarget, OP_add_brand);
-  }
-  else if (isTag(rval, "JSCheckConstructor"))
-  {
-    return pushOP(ctx, currTarget, OP_check_ctor);
-  }
-  else if (isTag(rval, "StackPop"))
-  {
-    return currTarget;
-  }
-  else if (isTag(rval, "JSForInNext"))
-  {
-    currTarget = lowerToStack(ctx, currTarget, rval->args[0]);
+    currTarget = lowerToStack(ctx, currTarget, currStmt->args[0]);
     currTarget = pushOP(ctx, currTarget, OP_for_in_next);
 
-    currTarget = keepNDropM(ctx, currTarget, 2, 1);
+    IridiumSEXP *doneTarget = currStmt->args[1];
+    assert(isTag(doneTarget, "EnvBinding"));
+    int doneTargetIDX = getFlagNumber(doneTarget, "REFIDX");
 
-    return currTarget;
+    IridiumSEXP *nextValTarget = currStmt->args[2];
+    assert(isTag(nextValTarget, "EnvBinding"));
+    int nextValTargetIDX = getFlagNumber(nextValTarget, "REFIDX");
+
+    currTarget = pushOP16(ctx, currTarget, OP_put_loc, doneTargetIDX);    // top of the stack contains <loop-done>
+    currTarget = pushOP16(ctx, currTarget, OP_put_loc, nextValTargetIDX); // top - 1 of the stack contains <loop-next>
+    return pushOP(ctx, currTarget, OP_drop);                              // drop enum_obj
   }
-  else if (isTag(rval, "JSForOfStart"))
+  else if (isTag(currStmt, "JSForOfStart"))
   {
     // Push obj onto the stack
-    currTarget = lowerToStack(ctx, currTarget, rval->args[0]);
+    currTarget = lowerToStack(ctx, currTarget, currStmt->args[0]);
 
     // obj -> enum_obj iterator_method catch_offset
     return pushOP(ctx, currTarget, OP_for_of_start);
-  }
-  else if (isTag(rval, "JSForOfNext"))
-  {
-    // [it, meth, off] -> [it, meth, off, result, done]
-    return pushOP16(ctx, currTarget, OP_for_of_next, 0);
-  }
-  else if (isTag(rval, "JSForOfIteratorClose"))
-  {
-    return pushOP(ctx, currTarget, OP_iterator_close);
-  }
-  else
-  {
-    fprintf(stderr, "TODO: unhandled RVal: %s\n", rval->tag);
-    exit(1);
-  }
-  return currTarget;
-}
 
-BCLList *handleEnvWrite(JSContext *ctx, BCLList *currTarget, IridiumSEXP *currStmt, bool saveResToStack)
-{
-  bool safe = getFlagBoolean(currStmt, "SAFE");
-  bool thisInit = getFlagBoolean(currStmt, "THISINIT");
-  bool isStrict = !hasFlag(currStmt, "SLOPPY");
+    // currTarget = pushOP(ctx, currTarget, OP_swap);
 
-  IridiumSEXP *loc = currStmt->args[0];
-  IridiumSEXP *rval = currStmt->args[1];
+    // IridiumSEXP *methodStackLocation = currStmt->args[1];
+    // int methodStackLocationIDX = getFlagNumber(methodStackLocation, "REFIDX");
+    // if (isTag(methodStackLocation, "EnvBinding")) {
+    //   currTarget = pushOP16(ctx, currTarget, OP_put_loc_check, methodStackLocationIDX);
+    // } else if (isTag(methodStackLocation, "RemoteEnvBinding")) {
+    //   currTarget = pushOP16(ctx, currTarget, OP_put_var_ref_check, methodStackLocationIDX);
+    // } else {
+    //   fprintf(stderr, "TODO: Expected a EnvBinding or RemoteEnvBinding!!");
+    // }
 
-  // Store something on the stack
-  currTarget = lowerToStack(ctx, currTarget, rval);
-  // Store that something where its required
-  return storeWhatevesOnTheStack(ctx, loc, currTarget, safe, thisInit, isStrict, saveResToStack);
-}
+    // currTarget = pushOP(ctx, currTarget, OP_swap);
 
-BCLList *handleIriStmt(JSContext *ctx, BCLList *currTarget, IridiumSEXP *currStmt)
-{
-  if (isTag(currStmt, "EnvWrite"))
-  {
-    currTarget = handleEnvWrite(ctx, currTarget, currStmt, false);
-  }
-  else if (isTag(currStmt, "FieldWrite") || isTag(currStmt, "JSComputedFieldWrite")) // Make fast cases for these too...
-  {
-    currTarget = lowerToStack(ctx, currTarget, currStmt);
-    return pushOP(ctx, currTarget, OP_drop);
+    // IridiumSEXP *methodItLocation = currStmt->args[2];
+    // int methodItLocationIDX = getFlagNumber(methodItLocation, "REFIDX");
+    // if (isTag(methodItLocation, "EnvBinding")) {
+    //   currTarget = pushOP16(ctx, currTarget, OP_put_loc_check, methodItLocationIDX);
+    // } else if (isTag(methodItLocation, "RemoteEnvBinding")) {
+    //   currTarget = pushOP16(ctx, currTarget, OP_put_var_ref_check, methodItLocationIDX);
+    // } else {
+    //   fprintf(stderr, "TODO: Expected a EnvBinding or RemoteEnvBinding!!");
+    // }
   }
-  else if (isTag(currStmt, "StackRetain"))
+  else if (isTag(currStmt, "JSForInStart"))
   {
-    if (currStmt->numArgs > 0)
+    // Push obj onto the stack
+    currTarget = lowerToStack(ctx, currTarget, currStmt->args[0]);
+
+    // obj -> enum_obj
+    currTarget = pushOP(ctx, currTarget, OP_for_in_start);
+    IridiumSEXP *stackLocation = currStmt->args[1];
+    int stackLocationIDX = getFlagNumber(stackLocation, "REFIDX");
+    if (isTag(stackLocation, "EnvBinding"))
     {
-      for (int i = 0; i < currStmt->numArgs; i++)
-      {
-        currTarget = lowerToStack(ctx, currTarget, currStmt->args[i]);
-      }
+      currTarget = pushOP16(ctx, currTarget, OP_put_loc_check, stackLocationIDX);
+    }
+    else if (isTag(stackLocation, "RemoteEnvBinding"))
+    {
+      currTarget = pushOP16(ctx, currTarget, OP_put_var_ref_check, stackLocationIDX);
+    }
+    else
+    {
+      fprintf(stderr, "TODO: Expected a EnvBinding or RemoteEnvBinding!!");
     }
-    return currTarget;
   }
-  else if (isTag(currStmt, "StackReject"))
+  else if (isTag(currStmt, "JSForOfNext"))
   {
-    if (currStmt->numArgs > 0)
+    // [it, meth, off] -> [it, meth, off, result, done]
+    currTarget = pushOP16(ctx, currTarget, OP_for_of_next, 0);
+
+    // Store <for-of-loop-done> = done
+    // Store <for-of-loop-next> = result
+    assert(currStmt->numArgs == 2);
+    for (int i = 0; i < currStmt->numArgs; i++)
     {
-      for (int i = 0; i < currStmt->numArgs; i++)
+      IridiumSEXP *stackLocation = currStmt->args[i];
+      int stackLocationIDX = getFlagNumber(stackLocation, "REFIDX");
+      if (isTag(stackLocation, "EnvBinding"))
       {
-        currTarget = lowerToStack(ctx, currTarget, currStmt->args[i]);
+        currTarget = pushOP16(ctx, currTarget, OP_put_loc_check, stackLocationIDX);
+      }
+      else if (isTag(stackLocation, "RemoteEnvBinding"))
+      {
+        currTarget = pushOP16(ctx, currTarget, OP_put_var_ref_check, stackLocationIDX);
+      }
+      else
+      {
+        fprintf(stderr, "TODO: Expected a EnvBinding or RemoteEnvBinding!!");
       }
     }
+  }
+  else if (isTag(currStmt, "EnvWrite"))
+  {
+    return handleEnvWrite(ctx, currTarget, currStmt);
+  }
+  else if (isTag(currStmt, "JSADDBRAND"))
+  {
+    currTarget = lowerToStack(ctx, currTarget, currStmt->args[0]);
+    currTarget = lowerToStack(ctx, currTarget, currStmt->args[1]);
+    return pushOP(ctx, currTarget, OP_add_brand);
+  }
+  else if (isTag(currStmt, "JSComputedFieldWrite"))
+  {
+    IridiumSEXP *receiver = currStmt->args[0];
+    currTarget = lowerToStack(ctx, currTarget, receiver);
 
-    int nVal = getFlagNumber(currStmt, "NVAL");
-    for (int i = 0; i < nVal; i++)
-    {
-      currTarget = pushOP(ctx, currTarget, OP_drop);
-    }
+    IridiumSEXP *field = currStmt->args[1];
+    currTarget = lowerToStack(ctx, currTarget, field);
+    currTarget = pushOP(ctx, currTarget, OP_to_propkey);
 
-    return currTarget;
+    IridiumSEXP *assnVal = currStmt->args[2];
+    currTarget = lowerToStack(ctx, currTarget, assnVal);
+
+    return pushOP(ctx, currTarget, OP_put_array_el); // obj prop val
   }
   else if (isTag(currStmt, "Throw"))
   {
     currTarget = lowerToStack(ctx, currTarget, currStmt->args[0]);
     return pushOP(ctx, currTarget, OP_throw);
   }
-
+  else if (isTag(currStmt, "JSCheckConstructor"))
+  {
+    return pushOP(ctx, currTarget, OP_check_ctor);
+  }
   else if (isTag(currStmt, "JSCatchContext"))
   {
     IridiumSEXP *loc = currStmt->args[0];
@@ -1617,15 +1475,17 @@ BCLList *handleIriStmt(JSContext *ctx, BCLList *currTarget, IridiumSEXP *currStm
     int refIdx = getFlagNumber(loc, "REFIDX");
     return pushOP16(ctx, currTarget, OP_put_loc, refIdx);
   }
+  else if (isTag(currStmt, "PushForOfCatchContext"))
+  {
+    return lowerToStack(ctx, currTarget, currStmt->args[0]);
+  }
   else if (isTag(currStmt, "IfJump"))
   {
     // Push check to stack
     currTarget = lowerToStack(ctx, currTarget, currStmt->args[0]);
 
-    bool isNot = hasFlag(currStmt, "NOT");
-
     // Jmp to TRUE if stack value is true
-    currTarget = pushOP32(ctx, currTarget, isNot ? OP_if_false : OP_if_true, getFlagNumber(currStmt, "IDX"));
+    currTarget = pushOP32(ctx, currTarget, OP_if_true, getFlagNumber(currStmt, "IDX"));
 
     return currTarget;
   }
@@ -1683,102 +1543,19 @@ BCLList *handleIriStmt(JSContext *ctx, BCLList *currTarget, IridiumSEXP *currStm
   {
     return currTarget;
   }
-  else if (isTag(currStmt, "JSImplicitBindingDeclaration"))
-  {
-    int OPID = getFlagNumber(currStmt, "OPID");
-    bool safe = getFlagBoolean(currStmt, "SAFE");
-    bool thisInit = getFlagBoolean(currStmt, "THISINIT");
-    bool isStrict = !hasFlag(currStmt, "SLOPPY");
-    switch (OPID)
-    {
-    case 0:
-    case 1:
-    case 2:
-    case 3:
-    case 4:
-    case 5:
-    case 6:
-    {
-      currTarget = pushOP8(ctx, currTarget, OP_special_object, OPID);
-      IridiumSEXP *loc = currStmt->args[0];
-      currTarget = storeWhatevesOnTheStack(ctx, loc, currTarget, safe, thisInit, isStrict, false);
-      break;
-    }
-    case 7:
-    case 8:
-    {
-      IridiumSEXP *loc = currStmt->args[0];
-      IridiumSEXP *args = currStmt->args[1];
-      ensureTag(args, "List");
-      assert(args->numArgs == 1);
-      currTarget = lowerToStack(ctx, currTarget, args->args[0]);
-      currTarget = pushOP(ctx, currTarget, OP_get_super);
-      currTarget = storeWhatevesOnTheStack(ctx, loc, currTarget, safe, thisInit, isStrict, false);
-      break;
-    }
-    case 9:
-    {
-      currTarget = pushOP(ctx, currTarget, OP_push_this);
-      IridiumSEXP *loc = currStmt->args[0];
-      currTarget = storeWhatevesOnTheStack(ctx, loc, currTarget, safe, thisInit, isStrict, false);
-      break;
-    }
-    case 10:
-    {
-      currTarget = pushOPConst(ctx, currTarget, OP_push_const, JS_UNINITIALIZED);
-      IridiumSEXP *loc = currStmt->args[0];
-      currTarget = storeWhatevesOnTheStack(ctx, loc, currTarget, safe, thisInit, isStrict, false);
-      break;
-    }
-    case 11:
-    {
-      currTarget = pushOP(ctx, currTarget, OP_undefined);
-      IridiumSEXP *loc = currStmt->args[0];
-      currTarget = storeWhatevesOnTheStack(ctx, loc, currTarget, safe, thisInit, isStrict, false);
-      break;
-    }
-    default:
-      fprintf(stderr, "TODO: OPID: %d for JSImplicitBindingDeclaration\n", OPID);
-      exit(1);
-      break;
-    }
-    return currTarget;
-  }
-  else if (isTag(currStmt, "JSMODULEMETAINIT"))
+  else if (isTag(currStmt, "JSTHISINIT"))
   {
-    currTarget = pushOP8(ctx, currTarget, OP_special_object, 6);
-
+    currTarget = pushOP(ctx, currTarget, OP_push_this);
     IridiumSEXP *thisLoc = currStmt->args[0];
     ensureTag(thisLoc, "EnvBinding");
     int refIdx = getFlagNumber(thisLoc, "REFIDX");
-
-    return pushOP16(ctx, currTarget, OP_put_loc, refIdx);
-  }
-  else if (isTag(currStmt, "JSARGUMENTSINIT"))
-  {
-    currTarget = pushOP8(ctx, currTarget, OP_special_object, 0);
-
-    IridiumSEXP *argsLoc = currStmt->args[0];
-    ensureTag(argsLoc, "EnvBinding");
-    int refIdx = getFlagNumber(argsLoc, "REFIDX");
-
     return pushOP16(ctx, currTarget, OP_put_loc, refIdx);
   }
-  else if (isTag(currStmt, "JSMARGUMENTSINIT"))
+  else if (isTag(currStmt, "CallSite"))
   {
-    currTarget = pushOP8(ctx, currTarget, OP_special_object, 1);
-
-    IridiumSEXP *argsLoc = currStmt->args[0];
-    ensureTag(argsLoc, "EnvBinding");
-    int refIdx = getFlagNumber(argsLoc, "REFIDX");
-
-    return pushOP16(ctx, currTarget, OP_put_loc, refIdx);
+    currTarget = lowerToStack(ctx, currTarget, currStmt);
+    return pushOP(ctx, currTarget, OP_drop);
   }
-  // else if (isTag(currStmt, "CallSite"))
-  // {
-  //   currTarget = lowerToStack(ctx, currTarget, currStmt);
-  //   return pushOP(ctx, currTarget, OP_drop);
-  // }
   else if (isTag(currStmt, "JSSUPEROBJINIT"))
   {
     currTarget = pushOP8(ctx, currTarget, OP_special_object, 4);
@@ -1805,7 +1582,34 @@ BCLList *handleIriStmt(JSContext *ctx, BCLList *currTarget, IridiumSEXP *currStm
     int refIdx = getFlagNumber(targetBinding, "REFIDX");
     return pushOP16(ctx, currTarget, OP_put_loc, refIdx);
   }
+  else if (isTag(currStmt, "JSHOMEOBJ"))
+  {
+    currTarget = pushOP8(ctx, currTarget, OP_special_object, 4);
+    IridiumSEXP *targetBinding = currStmt->args[0];
+    ensureTag(targetBinding, "EnvBinding");
+    int refIdx = getFlagNumber(targetBinding, "REFIDX");
+    return pushOP16(ctx, currTarget, OP_put_loc, refIdx);
+  }
+  else if (isTag(currStmt, "JSToObject"))
+  {
+    currTarget = lowerToStack(ctx, currTarget, currStmt->args[0]);
+    currTarget = pushOP(ctx, currTarget, OP_to_object);
 
+    IridiumSEXP *stackLocation = currStmt->args[1];
+    int stackLocationIDX = getFlagNumber(stackLocation, "REFIDX");
+    if (isTag(stackLocation, "EnvBinding"))
+    {
+      currTarget = pushOP16(ctx, currTarget, OP_put_loc_check, stackLocationIDX);
+    }
+    else if (isTag(stackLocation, "RemoteEnvBinding"))
+    {
+      currTarget = pushOP16(ctx, currTarget, OP_put_var_ref_check, stackLocationIDX);
+    }
+    else
+    {
+      fprintf(stderr, "TODO: Expected a EnvBinding or RemoteEnvBinding!!");
+    }
+  }
   else if (isTag(currStmt, "JSPrivateFieldWrite"))
   {
     currTarget = lowerToStack(ctx, currTarget, currStmt->args[0]);
@@ -1817,6 +1621,21 @@ BCLList *handleIriStmt(JSContext *ctx, BCLList *currTarget, IridiumSEXP *currStm
   {
     return pushOP(ctx, currTarget, OP_initial_yield);
   }
+  else if (isTag(currStmt, "JSClassMethodDefine"))
+  {
+    IridiumSEXP *where = currStmt->args[0];
+    currTarget = lowerToStack(ctx, currTarget, where);
+
+    IridiumSEXP *what = currStmt->args[2];
+    currTarget = lowerToStack(ctx, currTarget, what);
+
+    IridiumSEXP *field = currStmt->args[1];
+    ensureTag(field, "String");
+    JSAtom fieldAtom = JS_NewAtom(ctx, getFlagString(field, "IridiumPrimitive"));
+    currTarget = pushOP32(ctx, currTarget, OP_define_method, fieldAtom);
+    uint8_t op_flag = OP_DEFINE_METHOD_METHOD | OP_DEFINE_METHOD_ENUMERABLE;
+    return push8(ctx, currTarget, op_flag);
+  }
   else if (isTag(currStmt, "JSCopyDataProperties"))
   {
     // exc_obj
@@ -1834,26 +1653,7 @@ BCLList *handleIriStmt(JSContext *ctx, BCLList *currTarget, IridiumSEXP *currStm
     // OP_copy_data_properties
     currTarget = pushOP16(ctx, currTarget, OP_copy_data_properties, 68);
 
-    bool safe = getFlagBoolean(currStmt, "SAFE");
-    bool thisInit = getFlagBoolean(currStmt, "THISINIT");
-    bool isStrict = !hasFlag(currStmt, "SLOPPY");
-
-    IridiumSEXP *loc = currStmt->args[3];
-    currTarget = storeWhatevesOnTheStack(ctx, loc, currTarget, safe, thisInit, isStrict, false);
-
-    currTarget = pushOP(ctx, currTarget, OP_drop);
-    return pushOP(ctx, currTarget, OP_drop);
-  }
-  else if (isTag(currStmt, "Ret"))
-  {
-    return pushOP(ctx, currTarget, OP_ret);
-  }
-  else if (isTag(currStmt, "Yield"))
-  {
-    currTarget = lowerToStack(ctx, currTarget, currStmt->args[0]);
-    currTarget = pushOP(ctx, currTarget, OP_yield);
-
-    IridiumSEXP *stackLocation = currStmt->args[1];
+    IridiumSEXP *stackLocation = currStmt->args[3];
     int stackLocationIDX = getFlagNumber(stackLocation, "REFIDX");
     if (isTag(stackLocation, "EnvBinding"))
     {
@@ -1865,176 +1665,19 @@ BCLList *handleIriStmt(JSContext *ctx, BCLList *currTarget, IridiumSEXP *currStm
     }
     else
     {
-      fprintf(stderr, "YIELD: Expected a EnvBinding or RemoteEnvBinding!!");
-    }
-
-    stackLocation = currStmt->args[2];
-    stackLocationIDX = getFlagNumber(stackLocation, "REFIDX");
-    if (isTag(stackLocation, "EnvBinding"))
-    {
-      currTarget = pushOP16(ctx, currTarget, OP_put_loc_check, stackLocationIDX);
-    }
-    else if (isTag(stackLocation, "RemoteEnvBinding"))
-    {
-      currTarget = pushOP16(ctx, currTarget, OP_put_var_ref_check, stackLocationIDX);
-    }
-    else
-    {
-      fprintf(stderr, "YIELD: Expected a EnvBinding or RemoteEnvBinding!!");
-    }
-  }
-  else if (isTag(currStmt, "JSSloppyDecl"))
-  {
-    uint8_t check_flag = 0, define_flag = 0;
-
-#define DEFINE_GLOBAL_LEX_VAR (1 << 7)
-#define DEFINE_GLOBAL_FUNC_VAR (1 << 6)
-
-    if (hasFlag(currStmt, "JSLET"))
-    {
-      check_flag |= DEFINE_GLOBAL_LEX_VAR;
-      define_flag |= DEFINE_GLOBAL_LEX_VAR;
-      define_flag |= JS_PROP_WRITABLE;
-    }
-    else if (hasFlag(currStmt, "JSCONST"))
-    {
-      check_flag |= DEFINE_GLOBAL_LEX_VAR;
-      define_flag |= DEFINE_GLOBAL_LEX_VAR;
-    }
-    else if (hasFlag(currStmt, "JSVAR"))
-    {
-      // Redundant...
-      check_flag = 0;
-      check_flag = 0;
-    }
-    else
-    {
-      fprintf(stderr, "TODO: JSSloppyDecl invalid flag config\n");
-      exit(1);
-    }
-
-    char *name = getFlagString(currStmt, "NAME");
-    currTarget = pushOP32Flags(ctx, currTarget, OP_check_define_var, JS_NewAtom(ctx, name), check_flag);
-    currTarget = pushOP32Flags(ctx, currTarget, OP_define_var, JS_NewAtom(ctx, name), define_flag);
-
-    return currTarget;
-  }
-  else if (isTag(currStmt, "JSFuncDecl"))
-  {
-    IridiumSEXP *loc = currStmt->args[0];
-    IridiumSEXP *closure = currStmt->args[1];
-
-    if (isTag(loc, "GlobalBinding"))
-    {
-      char *name = getFlagString(loc, "NAME");
-      currTarget = pushOP32Flags(ctx, currTarget, OP_check_define_var, JS_NewAtom(ctx, name), 64);
-      currTarget = lowerToStack(ctx, currTarget, closure);
-      currTarget = pushOP32Flags(ctx, currTarget, OP_define_func, JS_NewAtom(ctx, name), 0);
-    }
-    else
-    {
-      fprintf(stderr, "TODO: unhandled JSFuncDecl case, expected a GlobalBinding\n");
-      exit(1);
+      fprintf(stderr, "TODO: Expected a EnvBinding or RemoteEnvBinding!!");
     }
-  }
-  else if (isTag(currStmt, "JSAppend"))
-  {
-    currTarget = lowerToStack(ctx, currTarget, currStmt->args[0]); // tmp
-    currTarget = lowerToStack(ctx, currTarget, currStmt->args[1]); // insertionIdx
-    currTarget = lowerToStack(ctx, currTarget, currStmt->args[2]); // spreadVal
-    currTarget = pushOP(ctx, currTarget, OP_append);
 
-    bool safe = getFlagBoolean(currStmt, "SAFE");
-    bool thisInit = getFlagBoolean(currStmt, "THISINIT");
-    bool isStrict = !hasFlag(currStmt, "SLOPPY");
-
-    { // InsertionIdxLoc
-      IridiumSEXP *insertionLoc = currStmt->args[3];
-      currTarget = storeWhatevesOnTheStack(ctx, insertionLoc, currTarget, safe, thisInit, isStrict, false);
-    }
-
-    { // tempLoc
-      IridiumSEXP *tmpLoc = currStmt->args[4];
-      currTarget = storeWhatevesOnTheStack(ctx, tmpLoc, currTarget, safe, thisInit, isStrict, false);
-    }
+    currTarget = pushOP(ctx, currTarget, OP_drop);
+    return pushOP(ctx, currTarget, OP_drop);
   }
-  else if (isTag(currStmt, "JSDefineObjProp"))
+  else if (isTag(currStmt, "JSIteratorClose"))
   {
-    IridiumSEXP *obj = currStmt->args[0];
-    currTarget = lowerToStack(ctx, currTarget, obj);
-    IridiumSEXP *field = currStmt->args[1];
-    IridiumSEXP *val = currStmt->args[2];
-
-    if (isTag(field, "String"))
-    {
-      currTarget = lowerToStack(ctx, currTarget, val);
-      JSAtom fieldAtom = JS_NewAtom(ctx, getFlagString(field, "IridiumPrimitive"));
-      currTarget = pushOP32(ctx, currTarget, OP_define_field, fieldAtom);
-    }
-    else
-    {
-      currTarget = lowerToStack(ctx, currTarget, field);
-      currTarget = lowerToStack(ctx, currTarget, val);
-      currTarget = pushOP(ctx, currTarget, OP_define_array_el);
-      currTarget = pushOP(ctx, currTarget, OP_drop);
-    }
-
-    bool safe = getFlagBoolean(currStmt, "SAFE");
-    bool thisInit = getFlagBoolean(currStmt, "THISINIT");
-    bool isStrict = !hasFlag(currStmt, "SLOPPY");
-
-    { // tempLoc
-      IridiumSEXP *loc = currStmt->args[3];
-      currTarget = storeWhatevesOnTheStack(ctx, loc, currTarget, safe, thisInit, isStrict, false);
-    }
+    return pushOP(ctx, currTarget, OP_iterator_close);
   }
-  else if (isTag(currStmt, "JSDefineObjMethod"))
+  else if (isTag(currStmt, "Ret"))
   {
-    uint8_t op_flag;
-    if (hasFlag(currStmt, "METHOD"))
-    {
-      op_flag = OP_DEFINE_METHOD_METHOD | OP_DEFINE_METHOD_ENUMERABLE;
-    }
-    else if (hasFlag(currStmt, "GET"))
-    {
-      op_flag = OP_DEFINE_METHOD_GETTER | OP_DEFINE_METHOD_ENUMERABLE;
-    }
-    else if (hasFlag(currStmt, "SET"))
-    {
-      op_flag = OP_DEFINE_METHOD_SETTER | OP_DEFINE_METHOD_ENUMERABLE;
-    }
-    else
-    {
-      fprintf(stderr, "TODO: JSDefineObjMethod invalid flag\n");
-      exit(1);
-    }
-
-    IridiumSEXP *obj = currStmt->args[0];
-    currTarget = lowerToStack(ctx, currTarget, obj);
-    IridiumSEXP *field = currStmt->args[1];
-    IridiumSEXP *val = currStmt->args[2];
-
-    if (isTag(field, "String"))
-    {
-      currTarget = lowerToStack(ctx, currTarget, val);
-      JSAtom fieldAtom = JS_NewAtom(ctx, getFlagString(field, "IridiumPrimitive"));
-      currTarget = pushOP32Flags(ctx, currTarget, OP_define_method, fieldAtom, op_flag);
-    }
-    else
-    {
-      currTarget = lowerToStack(ctx, currTarget, field);
-      currTarget = lowerToStack(ctx, currTarget, val);
-      currTarget = pushOPFlags(ctx, currTarget, OP_define_method_computed, op_flag);
-    }
-
-    bool safe = getFlagBoolean(currStmt, "SAFE");
-    bool thisInit = getFlagBoolean(currStmt, "THISINIT");
-    bool isStrict = !hasFlag(currStmt, "SLOPPY");
-
-    { // tempLoc
-      IridiumSEXP *loc = currStmt->args[3];
-      currTarget = storeWhatevesOnTheStack(ctx, loc, currTarget, safe, thisInit, isStrict, false);
-    }
+    return pushOP(ctx, currTarget, OP_ret);
   }
   else
   {
@@ -2137,8 +1780,7 @@ int findOffset(BCLList *bcList, int offset, int targetOffset)
   {
     if (bcList->isLabel && bcList->label == targetOffset)
     {
-      // return offset + short_opcode_info(bcList->bc).size - 1;
-      return offset - 1;
+      return offset + short_opcode_info(bcList->bc).size - 1;
     }
     else
     {
@@ -2160,12 +1802,12 @@ void patchGotos(BCLList *bcList, int currOffset, BCLList *startBcList)
       // fprintf(stdout, "Patching offset %d to %d\n", iriOffset, actualOffset);
       bcList->data.four = actualOffset - currOffset;
     }
-    else if (bcList->bc == OP_if_true || bcList->bc == OP_if_false)
+    else if (bcList->bc == OP_if_true)
     {
       uint32_t iriOffset = bcList->data.four;
       int actualOffset = findOffset(startBcList, 0, iriOffset);
       // fprintf(stdout, "Patching (ifTrue) offset %d to %d\n", iriOffset, actualOffset);
-      bcList->data.four = (actualOffset - currOffset);
+      bcList->data.four = actualOffset - currOffset;
     }
     patchGotos(bcList->next, currOffset + short_opcode_info(bcList->bc).size, startBcList);
   }
@@ -2210,12 +1852,21 @@ void populateBytecode(uint8_t *target, BCLList *currBC, int poolIDX)
     *t = currBC->data.four;
   }
 
-  if (currBC->hasFlags)
+  if (currBC->bc == OP_define_method || currBC->bc == OP_define_class)
   {
-    uint8_t *t = (uint8_t *)(target + short_opcode_info(currBC->bc).size - 1);
-    *t = currBC->flags;
+    uint8_t *t = (uint8_t *)(target + 5); // {0: OP} {atom: 1 2 3 4} {flag: 5}
+    // Next slot is the op_flag
+    *t = currBC->next->bc;
+    return populateBytecode(target + short_opcode_info(currBC->bc).size, currBC->next->next, poolIDX);
   }
 
+  if (currBC->bc == OP_define_method_computed)
+  {
+    uint8_t *t = (uint8_t *)(target + 2); // {0: OP} {flag: 1}
+    // Next slot is the op_flag
+    *t = currBC->next->bc;
+    return populateBytecode(target + short_opcode_info(currBC->bc).size, currBC->next->next, poolIDX);
+  }
   return populateBytecode(target + short_opcode_info(currBC->bc).size, currBC->next, poolIDX);
 }
 
@@ -2346,7 +1997,7 @@ int compute_stack_size(JSContext *ctx, uint8_t *bc_buf, int bcSize)
     oi = &short_opcode_info(op);
     // #ifdef ENABLE_DUMPS // JS_DUMP_BYTECODE_STACK
     //         if (check_dump_flag(ctx->rt, JS_DUMP_BYTECODE_STACK))
-    // printf("%5d: %10s %5d %5d\n", pos, oi->name, stack_len, catch_pos);
+    printf("%5d: %10s %5d %5d\n", pos, oi->name, stack_len, catch_pos);
     // #endif
     pos_next = pos + oi->size;
     if (pos_next > s->bc_len)
@@ -2517,7 +2168,7 @@ void dumpBCLList(JSContext *ctx, BCLList *temp)
   while (temp)
   {
     fprintf(stdout, "BC[%d]: %s (size = %d bytes)", i, short_opcode_info(temp->bc).name, short_opcode_info(temp->bc).size);
-    // assert(short_opcode_info(temp->bc).size == (temp->valueSize + 1));
+    assert(short_opcode_info(temp->bc).size == (temp->valueSize + 1));
 
     if (temp->bc == OP_push_const)
     {
@@ -2556,8 +2207,6 @@ void dumpBCLList(JSContext *ctx, BCLList *temp)
 
 JSValue generateQjsFunction(JSContext *ctx, IridiumSEXP *bbContainer, BCLList *startBC)
 {
-  bool isStrict = hasFlag(bbContainer, "STRICT");
-
   IridiumSEXP *bindingsSEXP = bbContainer->args[0];
   IridiumSEXP *localBindingsSEXP = bindingsSEXP->args[0];
   IridiumSEXP *remoteBindingsSEXP = bindingsSEXP->args[1];
@@ -2575,7 +2224,7 @@ JSValue generateQjsFunction(JSContext *ctx, IridiumSEXP *bbContainer, BCLList *s
   // Initialize var/arg count
   for (int i = 0; i < localBindingsSEXP->numArgs; i++)
   {
-    if (hasFlag(localBindingsSEXP->args[i], "JSARG") || hasFlag(localBindingsSEXP->args[i], "JSRESTARG"))
+    if (hasFlag(localBindingsSEXP->args[i], "JSARG"))
       arg_count++;
     else
       var_count++;
@@ -2617,6 +2266,7 @@ JSValue generateQjsFunction(JSContext *ctx, IridiumSEXP *bbContainer, BCLList *s
     b->vardefs = (JSVarDef *)((uint8_t *)b + vardefs_offset);
     b->arg_count = arg_count;
     b->var_count = var_count;
+    b->defined_arg_count = 0;
   }
 
   if (closure_var_count > 0)
@@ -2628,10 +2278,6 @@ JSValue generateQjsFunction(JSContext *ctx, IridiumSEXP *bbContainer, BCLList *s
   b->byte_code_buf = (uint8_t *)b + byte_code_offset;
   b->byte_code_len = byte_code_len;
 
-  // Set defined args count
-  int ecmaArgsCount = getFlagNumber(bbContainer, "ECMAArgs");
-  b->defined_arg_count = ecmaArgsCount;
-
   // Metadata
   b->func_name = JS_ATOM_NULL;
   b->filename = JS_ATOM_NULL;
@@ -2646,7 +2292,7 @@ JSValue generateQjsFunction(JSContext *ctx, IridiumSEXP *bbContainer, BCLList *s
   b->pc2line_len = 0;
 
   // Function flags
-  b->is_strict_mode = isStrict;
+  b->is_strict_mode = 1;
   b->has_prototype = 0;
   b->has_simple_parameter_list = 1;
   b->is_derived_class_constructor = 0;
@@ -2669,15 +2315,17 @@ JSValue generateQjsFunction(JSContext *ctx, IridiumSEXP *bbContainer, BCLList *s
   populateBytecode(b->byte_code_buf, startBC, 0);
   b->stack_size = compute_stack_size(ctx, b->byte_code_buf, b->byte_code_len);
 
-  // Initialize Args + Var Defs
+  // Initialize Var Defs
   for (int i = 0; i < var_count; i++)
   {
     IridiumSEXP *envBinding = localBindingsSEXP->args[i];
     ensureTag(envBinding, "EnvBinding");
 
+    int refIDX = getFlagNumber(envBinding, "REFIDX");
+    assert(refIDX == i && "Local VarDef idx not found");
     int scope_level = getFlagNumber(envBinding, "Scope");
     int scope_next = getFlagNumber(envBinding, "ParentScope");
-    char *name = getFlagString(envBinding, "NAME");
+    char *name = getFlagString(envBinding->args[0], "IridiumPrimitive");
 
     b->vardefs[i].var_name = JS_NewAtom(ctx, name);
     b->vardefs[i].scope_level = scope_level;
@@ -2689,9 +2337,10 @@ JSValue generateQjsFunction(JSContext *ctx, IridiumSEXP *bbContainer, BCLList *s
     b->vardefs[i].is_captured = 0;
     b->vardefs[i].is_static_private = 0;
 
-    if (hasFlag(envBinding, "JSARG") || hasFlag(envBinding, "JSRESTARG"))
+    if (hasFlag(envBinding, "JSARG"))
     {
-      // NONE
+      fprintf(stderr, "JSARG not expected...");
+      exit(1);
     }
     else if (hasFlag(envBinding, "JSLET") || hasFlag(envBinding, "JSVAR"))
     {
@@ -2727,7 +2376,7 @@ JSValue generateQjsFunction(JSContext *ctx, IridiumSEXP *bbContainer, BCLList *s
 
     ensureTag(next, "EnvBinding");
     IridiumSEXP *envBinding = next;
-    char *name = getFlagString(envBinding, "NAME");
+    char *name = getFlagString(envBinding->args[0], "IridiumPrimitive");
 
     b->closure_var[i].is_arg = false;
     b->closure_var[i].is_const = false;
@@ -2736,7 +2385,7 @@ JSValue generateQjsFunction(JSContext *ctx, IridiumSEXP *bbContainer, BCLList *s
     b->closure_var[i].var_idx = refIDX;
     b->closure_var[i].var_name = JS_NewAtom(ctx, name);
 
-    if (hasFlag(envBinding, "JSARG") || hasFlag(envBinding, "JSRESTARG"))
+    if (hasFlag(envBinding, "JSARG"))
     {
       b->closure_var[i].is_arg = true;
     }
@@ -2753,20 +2402,10 @@ JSValue generateQjsFunction(JSContext *ctx, IridiumSEXP *bbContainer, BCLList *s
       fprintf(stderr, "Valid flag not found...");
       exit(1);
     }
-
-    // If marked as namespace import
-    if (hasFlag(remoteBinding, "NSIMPORT"))
-    {
-      b->closure_var[i].is_local = true;
-      b->closure_var[i].is_arg = false;
-      b->closure_var[i].is_const = true;
-      b->closure_var[i].is_lexical = true;
-      b->closure_var[i].var_kind = JS_VAR_NORMAL;
-      b->closure_var[i].var_idx = refIDX;
-      b->closure_var[i].var_name = JS_NewAtom(ctx, name);
-    }
   }
 
+  printf("ADDR: %p\n", b);
+
   // Set fun kind
   if (hasFlag(bbContainer, "GENERATOR") && hasFlag(bbContainer, "ASYNC"))
   {
@@ -2782,11 +2421,6 @@ JSValue generateQjsFunction(JSContext *ctx, IridiumSEXP *bbContainer, BCLList *s
   }
 
   // Set special flags
-  if (hasFlag(bbContainer, "ARGUMENTS"))
-  {
-    b->arguments_allowed = 1;
-  }
-
   if (hasFlag(bbContainer, "PROTO"))
   {
     b->has_prototype = 1;
@@ -2829,22 +2463,16 @@ JSValue generateBytecode(JSContext *ctx, IridiumSEXP *node)
 {
   IridiumSEXP *file = node;
   ensureTag(file, "File");
-
-  // Entry 1: Module Requests
-  // Entry 2: Static Imports
-  // Entry 3: Static Exports
-  // Entry 4: Static Star Exports
-  uint8_t moduleMetaEntries = 4;
-  uint16_t numModules = node->numArgs - moduleMetaEntries;
+  ensureFlag(file, "JSModule");
 
   // dumpIridiumSEXP(stdout, file, 0);
 
-  JSValue *moduleList = malloc(numModules * sizeof(JSValue));
+  JSValue *moduleList = malloc(node->numArgs * sizeof(JSValue));
   int topLevelModuleIdx = -1;
 
-  for (int i = 0; i < numModules; ++i)
+  for (int i = 0; i < file->numArgs; ++i)
   {
-    IridiumSEXP *bbContainer = file->args[moduleMetaEntries + i];
+    IridiumSEXP *bbContainer = file->args[i];
     ensureTag(bbContainer, "BBContainer");
 
     bool isTopLevelModule = hasFlag(bbContainer, "TopLevel");
@@ -2891,15 +2519,17 @@ JSValue generateBytecode(JSContext *ctx, IridiumSEXP *node)
     // Free BCLList
     freeBCLList(ctx, startBC);
 
+    js_dump_function_bytecode(ctx, (JSFunctionBytecode *)res.u.ptr);
+
     moduleList[i] = res;
   }
 
   assert(topLevelModuleIdx >= 0);
 
   // Fill CPool with closures
-  for (int i = 0; i < numModules; i++)
+  for (int i = 0; i < file->numArgs; i++)
   {
-    IridiumSEXP *bbContainer = file->args[moduleMetaEntries + i];
+    IridiumSEXP *bbContainer = file->args[i];
     ensureTag(bbContainer, "BBContainer");
 
     IridiumSEXP *bindingsInfo = bbContainer->args[0];
@@ -2922,9 +2552,9 @@ JSValue generateBytecode(JSContext *ctx, IridiumSEXP *node)
       // Find the location of the target closure
       JSValue res;
       bool found = false;
-      for (int k = 0; k < numModules; k++)
+      for (int k = 0; k < file->numArgs; k++)
       {
-        IridiumSEXP *bbContainer = file->args[moduleMetaEntries + k];
+        IridiumSEXP *bbContainer = file->args[k];
         ensureTag(bbContainer, "BBContainer");
         int closureStartBBIDX = getFlagNumber(bbContainer, "StartBBIDX");
         if (closureStartBBIDX == targetStartBBIDX)
@@ -2940,188 +2570,10 @@ JSValue generateBytecode(JSContext *ctx, IridiumSEXP *node)
     }
   }
 
-  if (check_dump_flag(ctx, JS_DUMP_BYTECODE_FINAL))
-  {
-    fprintf(stdout, "[Iridium] Dumping all non-topLevel module code\n");
-  }
 
-  for (int i = 0; i < numModules; i++)
-  {
-    if (i == topLevelModuleIdx)
-      continue;
-    JSValue funBC = moduleList[i];
-    JSFunctionBytecode *b = (JSFunctionBytecode *)funBC.u.ptr;
-    if (check_dump_flag(ctx, JS_DUMP_BYTECODE_FINAL))
-    {
-      js_dump_function_bytecode(ctx, b);
-    }
-  }
   return moduleList[topLevelModuleIdx];
 }
 
-typedef struct IridiumLoadResult
-{
-  bool isModule;
-  void *ptr;
-} IridiumLoadResult;
-
-IridiumLoadResult compile_iri_module(JSContext *ctx, cJSON *json)
-{
-  cJSON *code = cJSON_GetObjectItem(json, "iridium");
-
-  if (!cJSON_IsArray(code))
-  {
-    fprintf(stderr, "Expected the iridium key to be an array...");
-    exit(1);
-  }
-
-  IridiumSEXP *iridiumCode = parseIridiumSEXP(code);
-
-  // Generate BC
-  JSValue moduleFunVal = generateBytecode(ctx, iridiumCode);
-
-  JSFunctionBytecode *b = (JSFunctionBytecode *)moduleFunVal.u.ptr;
-  bool isModule = hasFlag(iridiumCode, "JSModule");
-
-  if (!isModule)
-  {
-    if (check_dump_flag(ctx, JS_DUMP_BYTECODE_FINAL))
-    {
-      js_dump_function_bytecode(ctx, b);
-    }
-    return ((IridiumLoadResult){false, b});
-  }
-
-  // Module mode code
-  b->func_kind = JS_FUNC_ASYNC;
-
-  // Execute the file
-  cJSON *absoluteFilePath = cJSON_GetObjectItem(json, "absoluteFilePath");
-  JSModuleDef *m = js_new_module_def(ctx, JS_NewAtom(ctx, cJSON_GetStringValue(absoluteFilePath)));
-
-  // Bytecode container gets the filename
-  b->filename = JS_NewAtom(ctx, cJSON_GetStringValue(absoluteFilePath));
-
-  // Initialize Module
-  IridiumSEXP *moduleRequests = iridiumCode->args[0];
-  IridiumSEXP *staticImports = iridiumCode->args[1];
-  IridiumSEXP *staticExports = iridiumCode->args[2];
-  IridiumSEXP *starExports = iridiumCode->args[3];
-
-  if (moduleRequests->numArgs > 0)
-  {
-    // 1. Create External Module Requests
-    m->req_module_entries_count = moduleRequests->numArgs;
-    m->req_module_entries_size = m->req_module_entries_count;
-    m->req_module_entries = js_mallocz(ctx, sizeof(m->req_module_entries[0]) * m->req_module_entries_size);
-
-    for (int r = 0; r < moduleRequests->numArgs; ++r)
-    {
-      IridiumSEXP *moduleRequest = moduleRequests->args[r];
-      char *SOURCE = getFlagString(moduleRequest, "SOURCE");
-      m->req_module_entries[r].module_name = JS_NewAtom(ctx, SOURCE);
-    }
-  }
-
-  if (staticImports->numArgs > 0)
-  {
-    // 2. Link Static Import Targets
-    m->import_entries_count = staticImports->numArgs;
-    m->import_entries_size = m->import_entries_count;
-    m->import_entries = js_mallocz(ctx, sizeof(m->import_entries[0]) * m->import_entries_size);
-
-    for (int im = 0; im < staticImports->numArgs; ++im)
-    {
-      IridiumSEXP *staticImport = staticImports->args[im];
-
-      // Req Module IDX
-      int reqModuleIDX = getFlagNumber(staticImport, "REQIDX");
-
-      // Target IDX
-      IridiumSEXP *bindingTarget = staticImport->args[0];
-      ensureTag(bindingTarget, "RemoteEnvBinding");
-      int bindingTargetIDX = getFlagNumber(bindingTarget, "REFIDX");
-
-      // Field
-      IridiumSEXP *fieldToGet = staticImport->args[1];
-      ensureTag(fieldToGet, "String");
-
-      char *fieldName = getFlagString(fieldToGet, "IridiumPrimitive");
-
-      m->import_entries[im].var_idx = bindingTargetIDX;
-      m->import_entries[im].import_name = JS_NewAtom(ctx, fieldName);
-      m->import_entries[im].req_module_idx = reqModuleIDX;
-
-      if (!hasFlag(bindingTarget, "NSIMPORT"))
-      {
-        // This needs to be set to false if the import is not a namespace import, this is a mess!!
-        b->closure_var[bindingTargetIDX].is_local = false; // <- This was the problem!!!!
-      }
-    }
-  }
-
-  if (staticExports->numArgs > 0)
-  {
-    // 3. Link Exports
-    m->export_entries_count = staticExports->numArgs;
-    m->export_entries_size = m->export_entries_count;
-    m->export_entries = js_mallocz(ctx, sizeof(m->export_entries[0]) * m->export_entries_size);
-
-    for (int ex = 0; ex < staticExports->numArgs; ++ex)
-    {
-      IridiumSEXP *staticExport = staticExports->args[ex];
-
-      if (isTag(staticExport, "NamedReexport"))
-      {
-        // Module Request IDX
-        int reqIdx = getFlagNumber(staticExport, "REQIDX");
-        m->export_entries[ex].u.req_module_idx = reqIdx;
-        m->export_entries[ex].export_type = JS_EXPORT_TYPE_INDIRECT;
-        m->export_entries[ex].local_name = JS_NewAtom(ctx, "*");
-        m->export_entries[ex].export_name = JS_NewAtom(ctx, getFlagString(staticExport, "EXPORTNAME"));
-      }
-      else
-      {
-        // Stack Ref IDX
-        IridiumSEXP *bindingTarget = staticExport->args[0];
-        ensureTag(bindingTarget, "RemoteEnvBinding");
-        int bindingTargetIDX = getFlagNumber(bindingTarget, "REFIDX");
-
-        m->export_entries[ex].u.local.var_idx = bindingTargetIDX;
-        m->export_entries[ex].export_type = JS_EXPORT_TYPE_LOCAL;
-        m->export_entries[ex].local_name = JS_NewAtom(ctx, getFlagString(staticExport, "LOCALNAME"));
-        m->export_entries[ex].export_name = JS_NewAtom(ctx, getFlagString(staticExport, "EXPORTNAME"));
-      }
-    }
-  }
-
-  if (starExports->numArgs > 0)
-  {
-    // 4. Star Exports
-    m->star_export_entries_count = starExports->numArgs;
-    m->star_export_entries_size = m->star_export_entries_count;
-    m->star_export_entries = js_mallocz(ctx, sizeof(m->star_export_entries[0]) * m->star_export_entries_size);
-
-    for (int ex = 0; ex < starExports->numArgs; ++ex)
-    {
-      IridiumSEXP *starExport = starExports->args[ex];
-      // Req IDX
-      int reqIDX = getFlagNumber(starExport, "REQIDX");
-      m->star_export_entries[ex].req_module_idx = reqIDX;
-    }
-  }
-
-  if (check_dump_flag(ctx, JS_DUMP_BYTECODE_FINAL))
-  {
-    fprintf(stdout, "[Iridium] Dumping compiled topLevel code\n");
-    js_dump_function_bytecode(ctx, b);
-  }
-
-  m->func_obj = moduleFunVal;
-
-  return ((IridiumLoadResult){true, m});
-}
-
 void eval_iri_file(JSContext *ctx, const char *filename)
 {
   cJSON *json = load_json(filename);
@@ -3132,74 +2584,25 @@ void eval_iri_file(JSContext *ctx, const char *filename)
     return;
   }
 
-  IridiumLoadResult iriRes = compile_iri_module(ctx, json);
-  if (iriRes.isModule)
-  {
-    JSValue moduleVal = JS_NewModuleValue(ctx, iriRes.ptr);
-
-    JS_ResolveModule(ctx, moduleVal);
-    JSValue res = JS_EvalFunction(ctx, moduleVal);
-    JS_FreeValue(ctx, res);
-  }
-  else
-  {
-    JSValue func_val = JS_MKPTR(JS_TAG_FUNCTION_BYTECODE, iriRes.ptr);
-    JSValue res = JS_EvalFunction(ctx, func_val);
-    JS_FreeValue(ctx, res);
-  }
-
-  cJSON_Delete(json);
-}
-
-void eval_iri_pika(JSContext *ctx, const char *filename)
-{
-  cJSON *json = load_json(filename);
-
-  if (json == NULL)
-  {
-    printf("Failed to load JSON.\n");
-    return;
-  }
-
-  cJSON *pika = cJSON_GetObjectItem(json, "pika");
+  cJSON *code = cJSON_GetObjectItem(json, "iridium");
 
-  if (!cJSON_IsArray(pika))
+  if (!cJSON_IsArray(code))
   {
-    fprintf(stderr, "Invalid pika bundle...");
+    fprintf(stderr, "Expected the iridium key to be an array...");
     exit(1);
   }
 
-  IridiumLoadResult iriRes;
-
-  int numModules = cJSON_GetArraySize(pika);
-
-  for (int i = 0; i < numModules; i++)
-  {
-    cJSON *json = cJSON_GetArrayItem(pika, i);
-
-    IridiumLoadResult r = compile_iri_module(ctx, json);
-
-    if (i == 0)
-    {
-      iriRes = r;
-      // = JS_NewModuleValue(ctx, iriRes.ptr);
-    }
-  }
-
-  if (iriRes.isModule)
-  {
-    JSValue moduleVal = JS_NewModuleValue(ctx, iriRes.ptr);
+  IridiumSEXP *iridiumCode = parseIridiumSEXP(code);
+  
+  // Generate BC
+  JSValue moduleFunVal = generateBytecode(ctx, iridiumCode);
 
-    JS_ResolveModule(ctx, moduleVal);
-    JSValue res = JS_EvalFunction(ctx, moduleVal);
-    JS_FreeValue(ctx, res);
-  }
-  else
-  {
-    JSValue func_val = JS_MKPTR(JS_TAG_FUNCTION_BYTECODE, iriRes.ptr);
-    JSValue res = JS_EvalFunction(ctx, func_val);
-    JS_FreeValue(ctx, res);
-  }
+  // Execute the file
+  JSModuleDef *m = js_new_module_def(ctx, JS_NewAtom(ctx, "<unnamed>"));
+  m->func_obj = moduleFunVal;
+  JSValue moduleVal = JS_NewModuleValue(ctx, m);
+  JSValue res = JS_EvalFunction(ctx, moduleVal);
+  JS_FreeValue(ctx, res);
 
   cJSON_Delete(json);
 }
